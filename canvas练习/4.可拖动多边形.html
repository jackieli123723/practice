<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>


<canvas id="canvas" width="800" height="500" style="border:1px solid #666"></canvas>
拖动:<input type="checkbox" id="drag">
<script src="Polygn.js" type="text/javascript"></script>
<script>
    var canvas = document.querySelector('#canvas'),
        ctx = canvas.getContext('2d'),
        drag = document.querySelector('#drag'),
        start = {},
        now = {},
        imgCatch,
        side=4,
        startAngle=0,
        assistStyle = 'red',
        lineStyle = 'blue',
        polygnFillStyle = 'yellow',
        polygnStrokeStyle = '#000',
        isMouseDown = false,
        isDrag = false,
        nowPolygn,
        polygns=[];

    function drawGrid(color, stepx, stepy){
        ctx.strokeStyle = color;
        for( var i=0.5+stepx; i<canvas.width; i+=stepx){
            ctx.beginPath();
            ctx.moveTo(i,0);
            ctx.lineTo(i,canvas.height);
            ctx.stroke();
            ctx.closePath();
        }
        for( var i=0.5+stepy; i<canvas.height; i+=stepy){
            ctx.beginPath();
            ctx.moveTo(0,i);
            ctx.lineTo(canvas.width,i);
            ctx.stroke();
            ctx.closePath();
        }
    }

    drag.onchange = function(){
        isDrag = drag.checked;
    }

    canvas.onmousedown = function(e){
        e.preventDefault();
        if(isMouseDown) return;
        isMouseDown = true;
        start = windowToCanvas(e.clientX,e.clientY)
        if(isDrag){
            //拖动
            //判断拖动哪个
            nowPolygn = null;
           for( var i=polygns.length; --i>=0;){
               var len = Math.sqrt(Math.pow((start.x-polygns[i].x),2)
                                    +Math.pow((start.y-polygns[i].y),2));
               if(len<polygns[i].radius) {
                   //取出拖动的元素
                   nowPolygn = polygns.splice(i, 1)[0];
                   //重绘
                   reDrawAllPolygn();
                   break;
               }
           }
        }else{
            //绘制
            nowPolygn = new Polygn(start.x,start.y,0,side,startAngle,polygnStrokeStyle,polygnFillStyle);
        }
        if(nowPolygn) {
            saveData();
            drawPolygn(nowPolygn)
        }
    }

    canvas.onmousemove = function(e){
        e.preventDefault();
        if(!isMouseDown)return;
        now =windowToCanvas(e.clientX,e.clientY);
        if(nowPolygn){
            loadData();
            if(isDrag){
                nowPolygn.move(nowPolygn.x+now.x-start.x,nowPolygn.y+now.y-start.y);
                start = now;
            }else{
                updatePolynRadiu(e);
            }
            drawPolygn(nowPolygn);
            !isDrag && drawAssist(assistStyle,start.x,start.y)
        }
    }

    canvas.onmouseup = function(e){
        e.preventDefault();
        if(!isMouseDown)return;
        if(nowPolygn) {
            loadData();
            drawPolygn(nowPolygn)
            polygns.push(nowPolygn);
        }
        isMouseDown = false;
        nowPolygn = null;
        start={};
        now={};
    }

    function reDrawAllPolygn(){
        if(!nowPolygn) return;
        ctx.clearRect(0,0,canvas.width,canvas.height)
        drawGrid('#ccc',10,10);
        polygns.forEach((polygn)=>{
            drawPolygn(polygn)
        })
    }

    function  updatePolynRadiu(e){
        now = windowToCanvas(e.clientX,e.clientY);
        var radius = Math.min(Math.abs(now.x-start.x),Math.abs(now.y-start.y));
        nowPolygn.radius = radius
    }

    function drawAssist(color,x,y){
        ctx.save();

        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(x,0);
        ctx.lineTo(x,canvas.height);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0,y);
        ctx.lineTo(canvas.width,y);
        ctx.stroke();
        ctx.closePath();

        ctx.stroke();
    }

    function  windowToCanvas(x,y){
        var bbox = canvas.getBoundingClientRect();
        return { x: x - bbox.left * (canvas.width  / bbox.width),
            y: y - bbox.top  * (canvas.height / bbox.height) };
    }


    function saveData(){
        imgCatch = ctx.getImageData(0, 0,canvas.width,canvas.height);
    }

    function loadData(){
        if(imgCatch)
        ctx.putImageData(imgCatch,0,0);
    }

    function drawPolygn(polygn){
        polygn.strokeAndFill(ctx);
    }
    drawGrid('#ccc',10,10);
</script>
</body>
</html>